SQL Challenge

Prework (organizing dataset):
create table customers
(id INT,
country VARCHAR(50),
name VARCHAR(50),
PRIMARY KEY (id)
);


insert into customers (id, country, name) 
VALUES (1, 'DE', 'John Doe'),
(2, 'AT', 'John Snow'),
(3, 'DE', 'Johnny B. Goode');


create table orders
(id INT, 
number VARCHAR(50), 
country VARCHAR(50),
customer_id INT,
PRIMARY KEY (id),
KEY idx_fk_customer_id (customer_id),
CONSTRAINT fk_customer_id FOREIGN KEY (customer_id)
REFERENCES customers(id) ON DELETE RESTRICT ON UPDATE CASCADE
);

insert into orders (id, number, country, customer_id) 
Values (1, 'O-01', 'DE', 1),
(4, 'O-02', 'AT', 2),
(5, 'O-03', 'DE', 2),
(6, 'O-05', 'AT', 2),
(8, 'O-06', 'DE', 3),
(10, 'O-10', 'DE', 3),
(11, 'O-11', 'AT', 3),
(12, 'O-123', 'DE', 1);


Question 1:

with same1 as (select distinct c.name as name, count(o.id) over (partition by c.name ORDER BY c.name ASC ) AS same 
from orders o
join customers c on o.customer_id = c.id
where o.country = c.country), 
different1 as (select distinct c.name as name, count(o.id) over (partition by c.name ORDER BY c.name ASC ) AS different 
from orders o
join customers c on o.customer_id = c.id
where o.country <> c.country)
select name, same, COALESCE(different, 0) as different
from customers c
left join same1 s using(name)
left join different1 d using(name)
group by name;





Question 2:
select o.id AS start, lead(o.id) OVER(ORDER BY o.id) AS End
from orders o;

select (o.id+1) AS start, lead((o.id-1)) OVER(ORDER BY o.id) AS End
from orders o;

WITH orders(id) as (select 1  from dual union all
			select 4  from dual union all
			select 5  from dual union all
			select 6  from dual union all
			select 8 from dual union all
			select 10 from dual union all
			select 11 from dual union all
			select 12 from dual),
numbers AS (
SELECT row_number() over (ORDER BY id ASC ) row_num,
       id
FROM orders
)
                   
SELECT nb1.id+1 AS start,
       nb2.id-1 AS End
       
FROM numbers nb1

  INNER JOIN numbers nb2 ON nb1.row_num + 1 = nb2.row_num 
                        AND nb1.id + 1 < nb2.id




Question 3:
select max(start) as start_, max(End) as End_
from                       
(select *, case when groups1.End >= start then 0 else 1 end AS islandstartid, sum(case when groups1.End >= start then 0 else 1 end) over (order by groups1.row_num) as islandid                      
from(                      
SELECT row_number() over (ORDER BY number ASC) row_num, number, right(number, length(number) - 2)+1 AS start, lead(right(number, length(number) - 2)-1) OVER(ORDER BY number) AS End
from orders) groups1) islands
where number <> 'O-01' and number <> 'O-123'
group by islandid
order by start_;




select right(number, length(number) - 2)+1 AS 'start', lead(right(number, length(number) - 2)-1) OVER(ORDER BY o.number) AS End 
from orders o;










